// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"provid-backend/gen/core/model"
)

func newMailLog(db *gorm.DB, opts ...gen.DOOption) mailLog {
	_mailLog := mailLog{}

	_mailLog.mailLogDo.UseDB(db, opts...)
	_mailLog.mailLogDo.UseModel(&model.MailLog{})

	tableName := _mailLog.mailLogDo.TableName()
	_mailLog.ALL = field.NewAsterisk(tableName)
	_mailLog.ID = field.NewInt64(tableName, "id")
	_mailLog.UserID = field.NewString(tableName, "user_id")
	_mailLog.RecipientEmail = field.NewString(tableName, "recipient_email")
	_mailLog.Subject = field.NewString(tableName, "subject")
	_mailLog.TemplateName = field.NewString(tableName, "template_name")
	_mailLog.Status = field.NewString(tableName, "status")
	_mailLog.Provider = field.NewString(tableName, "provider")
	_mailLog.ProviderMessageID = field.NewString(tableName, "provider_message_id")
	_mailLog.ErrorMessage = field.NewString(tableName, "error_message")
	_mailLog.ErrorCode = field.NewString(tableName, "error_code")
	_mailLog.RetryCount = field.NewInt16(tableName, "retry_count")
	_mailLog.MaxRetries = field.NewInt16(tableName, "max_retries")
	_mailLog.NextRetryAt = field.NewTime(tableName, "next_retry_at")
	_mailLog.IP = field.NewString(tableName, "ip")
	_mailLog.Metadata = field.NewString(tableName, "metadata")
	_mailLog.SentAt = field.NewTime(tableName, "sent_at")
	_mailLog.DeliveredAt = field.NewTime(tableName, "delivered_at")
	_mailLog.OpenedAt = field.NewTime(tableName, "opened_at")
	_mailLog.ClickedAt = field.NewTime(tableName, "clicked_at")
	_mailLog.BouncedAt = field.NewTime(tableName, "bounced_at")
	_mailLog.CreatedAt = field.NewTime(tableName, "created_at")
	_mailLog.UpdatedAt = field.NewTime(tableName, "updated_at")

	_mailLog.fillFieldMap()

	return _mailLog
}

type mailLog struct {
	mailLogDo

	ALL               field.Asterisk
	ID                field.Int64
	UserID            field.String
	RecipientEmail    field.String
	Subject           field.String
	TemplateName      field.String
	Status            field.String
	Provider          field.String
	ProviderMessageID field.String
	ErrorMessage      field.String
	ErrorCode         field.String
	RetryCount        field.Int16
	MaxRetries        field.Int16
	NextRetryAt       field.Time
	IP                field.String
	Metadata          field.String
	SentAt            field.Time
	DeliveredAt       field.Time
	OpenedAt          field.Time
	ClickedAt         field.Time
	BouncedAt         field.Time
	CreatedAt         field.Time
	UpdatedAt         field.Time

	fieldMap map[string]field.Expr
}

func (m mailLog) Table(newTableName string) *mailLog {
	m.mailLogDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m mailLog) As(alias string) *mailLog {
	m.mailLogDo.DO = *(m.mailLogDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *mailLog) updateTableName(table string) *mailLog {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt64(table, "id")
	m.UserID = field.NewString(table, "user_id")
	m.RecipientEmail = field.NewString(table, "recipient_email")
	m.Subject = field.NewString(table, "subject")
	m.TemplateName = field.NewString(table, "template_name")
	m.Status = field.NewString(table, "status")
	m.Provider = field.NewString(table, "provider")
	m.ProviderMessageID = field.NewString(table, "provider_message_id")
	m.ErrorMessage = field.NewString(table, "error_message")
	m.ErrorCode = field.NewString(table, "error_code")
	m.RetryCount = field.NewInt16(table, "retry_count")
	m.MaxRetries = field.NewInt16(table, "max_retries")
	m.NextRetryAt = field.NewTime(table, "next_retry_at")
	m.IP = field.NewString(table, "ip")
	m.Metadata = field.NewString(table, "metadata")
	m.SentAt = field.NewTime(table, "sent_at")
	m.DeliveredAt = field.NewTime(table, "delivered_at")
	m.OpenedAt = field.NewTime(table, "opened_at")
	m.ClickedAt = field.NewTime(table, "clicked_at")
	m.BouncedAt = field.NewTime(table, "bounced_at")
	m.CreatedAt = field.NewTime(table, "created_at")
	m.UpdatedAt = field.NewTime(table, "updated_at")

	m.fillFieldMap()

	return m
}

func (m *mailLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *mailLog) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 22)
	m.fieldMap["id"] = m.ID
	m.fieldMap["user_id"] = m.UserID
	m.fieldMap["recipient_email"] = m.RecipientEmail
	m.fieldMap["subject"] = m.Subject
	m.fieldMap["template_name"] = m.TemplateName
	m.fieldMap["status"] = m.Status
	m.fieldMap["provider"] = m.Provider
	m.fieldMap["provider_message_id"] = m.ProviderMessageID
	m.fieldMap["error_message"] = m.ErrorMessage
	m.fieldMap["error_code"] = m.ErrorCode
	m.fieldMap["retry_count"] = m.RetryCount
	m.fieldMap["max_retries"] = m.MaxRetries
	m.fieldMap["next_retry_at"] = m.NextRetryAt
	m.fieldMap["ip"] = m.IP
	m.fieldMap["metadata"] = m.Metadata
	m.fieldMap["sent_at"] = m.SentAt
	m.fieldMap["delivered_at"] = m.DeliveredAt
	m.fieldMap["opened_at"] = m.OpenedAt
	m.fieldMap["clicked_at"] = m.ClickedAt
	m.fieldMap["bounced_at"] = m.BouncedAt
	m.fieldMap["created_at"] = m.CreatedAt
	m.fieldMap["updated_at"] = m.UpdatedAt
}

func (m mailLog) clone(db *gorm.DB) mailLog {
	m.mailLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m mailLog) replaceDB(db *gorm.DB) mailLog {
	m.mailLogDo.ReplaceDB(db)
	return m
}

type mailLogDo struct{ gen.DO }

type IMailLogDo interface {
	gen.SubQuery
	Debug() IMailLogDo
	WithContext(ctx context.Context) IMailLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMailLogDo
	WriteDB() IMailLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMailLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMailLogDo
	Not(conds ...gen.Condition) IMailLogDo
	Or(conds ...gen.Condition) IMailLogDo
	Select(conds ...field.Expr) IMailLogDo
	Where(conds ...gen.Condition) IMailLogDo
	Order(conds ...field.Expr) IMailLogDo
	Distinct(cols ...field.Expr) IMailLogDo
	Omit(cols ...field.Expr) IMailLogDo
	Join(table schema.Tabler, on ...field.Expr) IMailLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMailLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMailLogDo
	Group(cols ...field.Expr) IMailLogDo
	Having(conds ...gen.Condition) IMailLogDo
	Limit(limit int) IMailLogDo
	Offset(offset int) IMailLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMailLogDo
	Unscoped() IMailLogDo
	Create(values ...*model.MailLog) error
	CreateInBatches(values []*model.MailLog, batchSize int) error
	Save(values ...*model.MailLog) error
	First() (*model.MailLog, error)
	Take() (*model.MailLog, error)
	Last() (*model.MailLog, error)
	Find() ([]*model.MailLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MailLog, err error)
	FindInBatches(result *[]*model.MailLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.MailLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMailLogDo
	Assign(attrs ...field.AssignExpr) IMailLogDo
	Joins(fields ...field.RelationField) IMailLogDo
	Preload(fields ...field.RelationField) IMailLogDo
	FirstOrInit() (*model.MailLog, error)
	FirstOrCreate() (*model.MailLog, error)
	FindByPage(offset int, limit int) (result []*model.MailLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMailLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m mailLogDo) Debug() IMailLogDo {
	return m.withDO(m.DO.Debug())
}

func (m mailLogDo) WithContext(ctx context.Context) IMailLogDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m mailLogDo) ReadDB() IMailLogDo {
	return m.Clauses(dbresolver.Read)
}

func (m mailLogDo) WriteDB() IMailLogDo {
	return m.Clauses(dbresolver.Write)
}

func (m mailLogDo) Session(config *gorm.Session) IMailLogDo {
	return m.withDO(m.DO.Session(config))
}

func (m mailLogDo) Clauses(conds ...clause.Expression) IMailLogDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m mailLogDo) Returning(value interface{}, columns ...string) IMailLogDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m mailLogDo) Not(conds ...gen.Condition) IMailLogDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m mailLogDo) Or(conds ...gen.Condition) IMailLogDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m mailLogDo) Select(conds ...field.Expr) IMailLogDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m mailLogDo) Where(conds ...gen.Condition) IMailLogDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m mailLogDo) Order(conds ...field.Expr) IMailLogDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m mailLogDo) Distinct(cols ...field.Expr) IMailLogDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m mailLogDo) Omit(cols ...field.Expr) IMailLogDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m mailLogDo) Join(table schema.Tabler, on ...field.Expr) IMailLogDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m mailLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMailLogDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m mailLogDo) RightJoin(table schema.Tabler, on ...field.Expr) IMailLogDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m mailLogDo) Group(cols ...field.Expr) IMailLogDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m mailLogDo) Having(conds ...gen.Condition) IMailLogDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m mailLogDo) Limit(limit int) IMailLogDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m mailLogDo) Offset(offset int) IMailLogDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m mailLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMailLogDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m mailLogDo) Unscoped() IMailLogDo {
	return m.withDO(m.DO.Unscoped())
}

func (m mailLogDo) Create(values ...*model.MailLog) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m mailLogDo) CreateInBatches(values []*model.MailLog, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m mailLogDo) Save(values ...*model.MailLog) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m mailLogDo) First() (*model.MailLog, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MailLog), nil
	}
}

func (m mailLogDo) Take() (*model.MailLog, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MailLog), nil
	}
}

func (m mailLogDo) Last() (*model.MailLog, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MailLog), nil
	}
}

func (m mailLogDo) Find() ([]*model.MailLog, error) {
	result, err := m.DO.Find()
	return result.([]*model.MailLog), err
}

func (m mailLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MailLog, err error) {
	buf := make([]*model.MailLog, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m mailLogDo) FindInBatches(result *[]*model.MailLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m mailLogDo) Attrs(attrs ...field.AssignExpr) IMailLogDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m mailLogDo) Assign(attrs ...field.AssignExpr) IMailLogDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m mailLogDo) Joins(fields ...field.RelationField) IMailLogDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m mailLogDo) Preload(fields ...field.RelationField) IMailLogDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m mailLogDo) FirstOrInit() (*model.MailLog, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MailLog), nil
	}
}

func (m mailLogDo) FirstOrCreate() (*model.MailLog, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MailLog), nil
	}
}

func (m mailLogDo) FindByPage(offset int, limit int) (result []*model.MailLog, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m mailLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m mailLogDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m mailLogDo) Delete(models ...*model.MailLog) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *mailLogDo) withDO(do gen.Dao) *mailLogDo {
	m.DO = *do.(*gen.DO)
	return m
}
