// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"provid-backend/gen/core/model"
)

func newUserPasswordCredential(db *gorm.DB, opts ...gen.DOOption) userPasswordCredential {
	_userPasswordCredential := userPasswordCredential{}

	_userPasswordCredential.userPasswordCredentialDo.UseDB(db, opts...)
	_userPasswordCredential.userPasswordCredentialDo.UseModel(&model.UserPasswordCredential{})

	tableName := _userPasswordCredential.userPasswordCredentialDo.TableName()
	_userPasswordCredential.ALL = field.NewAsterisk(tableName)
	_userPasswordCredential.UserID = field.NewString(tableName, "user_id")
	_userPasswordCredential.PasswordHash = field.NewString(tableName, "password_hash")
	_userPasswordCredential.PasswordAlgo = field.NewString(tableName, "password_algo")
	_userPasswordCredential.PasswordUpdatedAt = field.NewTime(tableName, "password_updated_at")
	_userPasswordCredential.MustChangePassword = field.NewBool(tableName, "must_change_password")
	_userPasswordCredential.CreatedAt = field.NewTime(tableName, "created_at")
	_userPasswordCredential.UpdatedAt = field.NewTime(tableName, "updated_at")

	_userPasswordCredential.fillFieldMap()

	return _userPasswordCredential
}

type userPasswordCredential struct {
	userPasswordCredentialDo

	ALL                field.Asterisk
	UserID             field.String
	PasswordHash       field.String
	PasswordAlgo       field.String
	PasswordUpdatedAt  field.Time
	MustChangePassword field.Bool
	CreatedAt          field.Time
	UpdatedAt          field.Time

	fieldMap map[string]field.Expr
}

func (u userPasswordCredential) Table(newTableName string) *userPasswordCredential {
	u.userPasswordCredentialDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u userPasswordCredential) As(alias string) *userPasswordCredential {
	u.userPasswordCredentialDo.DO = *(u.userPasswordCredentialDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *userPasswordCredential) updateTableName(table string) *userPasswordCredential {
	u.ALL = field.NewAsterisk(table)
	u.UserID = field.NewString(table, "user_id")
	u.PasswordHash = field.NewString(table, "password_hash")
	u.PasswordAlgo = field.NewString(table, "password_algo")
	u.PasswordUpdatedAt = field.NewTime(table, "password_updated_at")
	u.MustChangePassword = field.NewBool(table, "must_change_password")
	u.CreatedAt = field.NewTime(table, "created_at")
	u.UpdatedAt = field.NewTime(table, "updated_at")

	u.fillFieldMap()

	return u
}

func (u *userPasswordCredential) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *userPasswordCredential) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 7)
	u.fieldMap["user_id"] = u.UserID
	u.fieldMap["password_hash"] = u.PasswordHash
	u.fieldMap["password_algo"] = u.PasswordAlgo
	u.fieldMap["password_updated_at"] = u.PasswordUpdatedAt
	u.fieldMap["must_change_password"] = u.MustChangePassword
	u.fieldMap["created_at"] = u.CreatedAt
	u.fieldMap["updated_at"] = u.UpdatedAt
}

func (u userPasswordCredential) clone(db *gorm.DB) userPasswordCredential {
	u.userPasswordCredentialDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u userPasswordCredential) replaceDB(db *gorm.DB) userPasswordCredential {
	u.userPasswordCredentialDo.ReplaceDB(db)
	return u
}

type userPasswordCredentialDo struct{ gen.DO }

type IUserPasswordCredentialDo interface {
	gen.SubQuery
	Debug() IUserPasswordCredentialDo
	WithContext(ctx context.Context) IUserPasswordCredentialDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserPasswordCredentialDo
	WriteDB() IUserPasswordCredentialDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserPasswordCredentialDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserPasswordCredentialDo
	Not(conds ...gen.Condition) IUserPasswordCredentialDo
	Or(conds ...gen.Condition) IUserPasswordCredentialDo
	Select(conds ...field.Expr) IUserPasswordCredentialDo
	Where(conds ...gen.Condition) IUserPasswordCredentialDo
	Order(conds ...field.Expr) IUserPasswordCredentialDo
	Distinct(cols ...field.Expr) IUserPasswordCredentialDo
	Omit(cols ...field.Expr) IUserPasswordCredentialDo
	Join(table schema.Tabler, on ...field.Expr) IUserPasswordCredentialDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserPasswordCredentialDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserPasswordCredentialDo
	Group(cols ...field.Expr) IUserPasswordCredentialDo
	Having(conds ...gen.Condition) IUserPasswordCredentialDo
	Limit(limit int) IUserPasswordCredentialDo
	Offset(offset int) IUserPasswordCredentialDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserPasswordCredentialDo
	Unscoped() IUserPasswordCredentialDo
	Create(values ...*model.UserPasswordCredential) error
	CreateInBatches(values []*model.UserPasswordCredential, batchSize int) error
	Save(values ...*model.UserPasswordCredential) error
	First() (*model.UserPasswordCredential, error)
	Take() (*model.UserPasswordCredential, error)
	Last() (*model.UserPasswordCredential, error)
	Find() ([]*model.UserPasswordCredential, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserPasswordCredential, err error)
	FindInBatches(result *[]*model.UserPasswordCredential, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.UserPasswordCredential) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserPasswordCredentialDo
	Assign(attrs ...field.AssignExpr) IUserPasswordCredentialDo
	Joins(fields ...field.RelationField) IUserPasswordCredentialDo
	Preload(fields ...field.RelationField) IUserPasswordCredentialDo
	FirstOrInit() (*model.UserPasswordCredential, error)
	FirstOrCreate() (*model.UserPasswordCredential, error)
	FindByPage(offset int, limit int) (result []*model.UserPasswordCredential, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserPasswordCredentialDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userPasswordCredentialDo) Debug() IUserPasswordCredentialDo {
	return u.withDO(u.DO.Debug())
}

func (u userPasswordCredentialDo) WithContext(ctx context.Context) IUserPasswordCredentialDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userPasswordCredentialDo) ReadDB() IUserPasswordCredentialDo {
	return u.Clauses(dbresolver.Read)
}

func (u userPasswordCredentialDo) WriteDB() IUserPasswordCredentialDo {
	return u.Clauses(dbresolver.Write)
}

func (u userPasswordCredentialDo) Session(config *gorm.Session) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Session(config))
}

func (u userPasswordCredentialDo) Clauses(conds ...clause.Expression) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userPasswordCredentialDo) Returning(value interface{}, columns ...string) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userPasswordCredentialDo) Not(conds ...gen.Condition) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userPasswordCredentialDo) Or(conds ...gen.Condition) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userPasswordCredentialDo) Select(conds ...field.Expr) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userPasswordCredentialDo) Where(conds ...gen.Condition) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userPasswordCredentialDo) Order(conds ...field.Expr) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userPasswordCredentialDo) Distinct(cols ...field.Expr) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userPasswordCredentialDo) Omit(cols ...field.Expr) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userPasswordCredentialDo) Join(table schema.Tabler, on ...field.Expr) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userPasswordCredentialDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserPasswordCredentialDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userPasswordCredentialDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserPasswordCredentialDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userPasswordCredentialDo) Group(cols ...field.Expr) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userPasswordCredentialDo) Having(conds ...gen.Condition) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userPasswordCredentialDo) Limit(limit int) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userPasswordCredentialDo) Offset(offset int) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userPasswordCredentialDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userPasswordCredentialDo) Unscoped() IUserPasswordCredentialDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userPasswordCredentialDo) Create(values ...*model.UserPasswordCredential) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userPasswordCredentialDo) CreateInBatches(values []*model.UserPasswordCredential, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userPasswordCredentialDo) Save(values ...*model.UserPasswordCredential) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userPasswordCredentialDo) First() (*model.UserPasswordCredential, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserPasswordCredential), nil
	}
}

func (u userPasswordCredentialDo) Take() (*model.UserPasswordCredential, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserPasswordCredential), nil
	}
}

func (u userPasswordCredentialDo) Last() (*model.UserPasswordCredential, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserPasswordCredential), nil
	}
}

func (u userPasswordCredentialDo) Find() ([]*model.UserPasswordCredential, error) {
	result, err := u.DO.Find()
	return result.([]*model.UserPasswordCredential), err
}

func (u userPasswordCredentialDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserPasswordCredential, err error) {
	buf := make([]*model.UserPasswordCredential, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userPasswordCredentialDo) FindInBatches(result *[]*model.UserPasswordCredential, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userPasswordCredentialDo) Attrs(attrs ...field.AssignExpr) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userPasswordCredentialDo) Assign(attrs ...field.AssignExpr) IUserPasswordCredentialDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userPasswordCredentialDo) Joins(fields ...field.RelationField) IUserPasswordCredentialDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userPasswordCredentialDo) Preload(fields ...field.RelationField) IUserPasswordCredentialDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userPasswordCredentialDo) FirstOrInit() (*model.UserPasswordCredential, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserPasswordCredential), nil
	}
}

func (u userPasswordCredentialDo) FirstOrCreate() (*model.UserPasswordCredential, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserPasswordCredential), nil
	}
}

func (u userPasswordCredentialDo) FindByPage(offset int, limit int) (result []*model.UserPasswordCredential, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userPasswordCredentialDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userPasswordCredentialDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userPasswordCredentialDo) Delete(models ...*model.UserPasswordCredential) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userPasswordCredentialDo) withDO(do gen.Dao) *userPasswordCredentialDo {
	u.DO = *do.(*gen.DO)
	return u
}
